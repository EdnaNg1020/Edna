<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>小車躲避障礙物 - 寬螢幕風景版</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      font-family: 'Segoe UI', Arial, sans-serif;
      color: white;
    }
    canvas {
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0, 200, 255, 0.3);
      background: #0d0d1a;
      margin-bottom: 15px;
    }
    #restartBtn {
      padding: 12px 24px;
      font-size: 18px;
      background: linear-gradient(to bottom, #ff6b6b, #d32f2f);
      color: white;
      border: none;
      border-radius: 30px;
      cursor: pointer;
      display: none; /* 初始隱藏 */
      font-weight: bold;
      letter-spacing: 1px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      transition: transform 0.1s, background 0.3s;
    }
    #restartBtn:hover {
      background: linear-gradient(to bottom, #ff7b7b, #e53935);
      transform: scale(1.05);
    }
    #scoreDisplay {
      font-size: 22px;
      margin-bottom: 8px;
      text-shadow: 0 0 8px rgba(0, 255, 200, 0.7);
      font-weight: bold;
    }
    #highScoreDisplay {
      font-size: 16px;
      color: #ffd700;
      text-shadow: 0 0 6px rgba(255, 215, 0, 0.6);
    }
  </style>
</head>
<body>
<div id="scoreDisplay">得分: 0</div>
<div id="highScoreDisplay">最高分: 0</div>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<button id="restartBtn" onclick="restartGame()">重新開始</button>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreDisplay = document.getElementById('scoreDisplay');
  const highScoreDisplay = document.getElementById('highScoreDisplay');
  const restartBtn = document.getElementById('restartBtn');

  // ✅ 調整車道：適配 400px 寬度，留出左右風景空間
  const lanes = [75, 200, 325]; // 左 中 右
  const laneDividers = [137, 263]; // (75+200)/2 ≈ 137, (200+325)/2 ≈ 263

  let playerLane = 1;
  const carWidth = 45; // 稍微加大
  const carHeight = 60;

  // === 路邊風景物件 ===
  const scenery = [];
  function initScenery() {
    scenery.length = 0;
    const totalHeight = canvas.height + 600;
    // 左側：房子 (x < 0)
    for (let y = -300; y < totalHeight; y += 130 + Math.random() * 90) {
      if (Math.random() > 0.4) {
        scenery.push({
          type: 'house',
          x: -60 - Math.random() * 30, // 更遠左側
          y: y,
          width: 30 + Math.random() * 12,
          height: 45 + Math.random() * 25
        });
      }
    }
    // 右側：樹 (x > canvas.width)
    for (let y = -250; y < totalHeight; y += 110 + Math.random() * 80) {
      if (Math.random() > 0.3) {
        scenery.push({
          type: 'tree',
          x: canvas.width + 30 + Math.random() * 30, // 更遠右側
          y: y,
          trunkWidth: 7 + Math.random() * 5,
          trunkHeight: 22 + Math.random() * 12,
          crownRadius: 14 + Math.random() * 7
        });
      }
    }
  }

  // 遊戲狀態
  let obstacles = [];
  let particles = [];
  let baseSpeed = 3;
  let speed = baseSpeed;
  let frameCount = 0;
  let gameOver = false;
  let score = 0;
  let highScore = localStorage.getItem('carGameHighScore') || 0;
  highScoreDisplay.textContent = '最高分: ' + highScore;

  initScenery();

  // 按鍵控制
  document.addEventListener('keydown', (e) => {
    if (gameOver) return;
    if (e.key === 'ArrowLeft' && playerLane > 0) playerLane--;
    else if (e.key === 'ArrowRight' && playerLane < 2) playerLane++;
  });

  // 生成障礙物
  function spawnObstacle() {
    const lastObs = obstacles.length > 0 ? obstacles[obstacles.length - 1] : null;
    if (lastObs && lastObs.y + carHeight + 150 > canvas.height) return;
    if (obstacles.length >= 2) return;

    let type, chosenLanes, attempts = 0;
    while (attempts < 10) {
      type = Math.floor(Math.random() * 3);
      if (type === 0) chosenLanes = [Math.floor(Math.random() * 3)];
      else if (type === 1) chosenLanes = [0, 1];
      else chosenLanes = [1, 2];

      const safeLanes = [0,1,2].filter(lane => !chosenLanes.includes(lane));
      if (safeLanes.length === 0) continue;

      const doubleLaneCount = obstacles.filter(o => o.lanes.length > 1).length;
      if (doubleLaneCount >= 1 && chosenLanes.length > 1) continue;

      if (chosenLanes.length === 1) {
        let consecutive = 0;
        for (let i = obstacles.length - 1; i >= Math.max(0, obstacles.length - 3); i--) {
          if (obstacles[i].lanes.includes(chosenLanes[0])) consecutive++;
        }
        if (consecutive >= 2) continue;
      }
      break;
      attempts++;
    }
    if (attempts >= 10) return;

    obstacles.push({ lanes: chosenLanes, y: -carHeight, width: carWidth, height: carHeight });
  }

  // 更新邏輯
  function update() {
    if (gameOver) return;

    frameCount++;
    score++;
    speed = Math.min(baseSpeed + Math.floor(score / 600) * 0.4, 9);

    const spawnInterval = Math.max(30, 45 - Math.floor(score / 1000));
    if (frameCount % spawnInterval === 0) {
      if (Math.random() > 0.4) spawnObstacle();
    }

    // 更新障礙物
    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].y += speed;
      if (obstacles[i].y > canvas.height) {
        obstacles.splice(i, 1);
        continue;
      }

      const playerY = canvas.height - carHeight - 20;
      if (obstacles[i].lanes.includes(playerLane) && obstacles[i].y + carHeight > playerY) {
        gameOver = true;
        createExplosion(lanes[playerLane], playerY + carHeight / 2);
        playSound(120, 0.15, 'square');
        
        const finalScore = Math.floor(score / 30);
        if (finalScore > highScore) {
          highScore = finalScore;
          localStorage.setItem('carGameHighScore', highScore);
          highScoreDisplay.textContent = '最高分: ' + highScore;
        }
        
        // ✅ 關鍵修正：確保按鈕出現 + 滾動到可見位置
        restartBtn.style.display = 'block';
        setTimeout(() => {
          restartBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
          restartBtn.focus();
        }, 100);
        return;
      }
    }

    // 更新風景
    for (let i = scenery.length - 1; i >= 0; i--) {
      scenery[i].y += speed;
      if (scenery[i].y > canvas.height + 300) {
        scenery.splice(i, 1);
      }
    }

    // 更新粒子
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.life--;
      if (p.life <= 0) particles.splice(i, 1);
    }

    scoreDisplay.textContent = '得分: ' + Math.floor(score / 30);
  }

  // 粒子爆炸
  function createExplosion(x, y) {
    for (let i = 0; i < 25; i++) {
      particles.push({
        x: x, y: y,
        vx: (Math.random() - 0.5) * 8,
        vy: (Math.random() - 0.5) * 8 - 2,
        life: 25 + Math.random() * 15,
        color: `hsl(${Math.random() * 20 + 340}, 90%, 60%)`
      });
    }
  }

  // 繪製圓角矩形
  function drawRoundedRect(x, y, width, height, radius, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // 繪製房子
  function drawHouse(x, y, w, h) {
    ctx.fillStyle = '#8d6e63';
    ctx.fillRect(x, y, w, h);
    ctx.fillStyle = '#5d4037';
    ctx.beginPath();
    ctx.moveTo(x - 4, y);
    ctx.lineTo(x + w / 2, y - w * 0.8);
    ctx.lineTo(x + w + 4, y);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#ffecb3';
    ctx.fillRect(x + w * 0.2, y + h * 0.3, w * 0.25, h * 0.3);
    ctx.fillRect(x + w * 0.55, y + h * 0.3, w * 0.25, h * 0.3);
  }

  // 繪製樹
  function drawTree(x, y, trunkW, trunkH, crownR) {
    ctx.fillStyle = '#5d4037';
    ctx.fillRect(x - trunkW / 2, y, trunkW, trunkH);
    ctx.fillStyle = '#4caf50';
    ctx.beginPath();
    ctx.arc(x, y, crownR, 0, Math.PI * 2);
    ctx.fill();
  }

  // 繪製
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 背景道路（只畫中央 300px，兩側留黑顯風景）
    ctx.fillStyle = '#0f0f1f';
    ctx.fillRect(50, 0, 300, canvas.height); // 道路寬 300px，居中

    // 繪製風景（在道路外）
    scenery.forEach(obj => {
      if (obj.type === 'house') {
        drawHouse(obj.x, obj.y, obj.width, obj.height);
      } else if (obj.type === 'tree') {
        drawTree(obj.x, obj.y, obj.trunkWidth, obj.trunkHeight, obj.crownRadius);
      }
    });

    // 車道分隔線（只在道路內）
    ctx.strokeStyle = 'rgba(200, 200, 255, 0.3)';
    ctx.lineWidth = 2;
    ctx.setLineDash([12, 12]);
    for (const x of laneDividers) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    ctx.setLineDash([]);
    ctx.lineWidth = 1;

    // 玩家小車
    ctx.fillStyle = '#4fc3f7';
    ctx.shadowColor = '#4fc3f7';
    ctx.shadowBlur = 15;
    drawRoundedRect(
      lanes[playerLane] - carWidth / 2,
      canvas.height - carHeight - 20,
      carWidth,
      carHeight,
      8,
      true,
      false
    );
    ctx.shadowBlur = 0;

    // 小車車窗
    ctx.fillStyle = '#bbdefb';
    drawRoundedRect(
      lanes[playerLane] - carWidth / 2 + 9,
      canvas.height - carHeight - 20 + 8,
      carWidth - 18,
      carHeight / 2 - 8,
      4,
      true,
      false
    );

    // 障礙物
    obstacles.forEach(obs => {
      obs.lanes.forEach(laneIndex => {
        const x = lanes[laneIndex] - carWidth / 2;
        const y = obs.y;

        ctx.fillStyle = '#ff5252';
        ctx.shadowColor = '#ff5252';
        ctx.shadowBlur = 10;
        drawRoundedRect(x, y, carWidth, carHeight, 6, true, false);
        ctx.shadowBlur = 0;

        ctx.fillStyle = '#ffebee';
        for (let i = 0; i < 3; i++) {
          ctx.fillRect(x + 6, y + 10 + i * 16, carWidth - 12, 3);
        }
      });
    });

    // 粒子
    particles.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.life / 40;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
  }

  // 音效
  function playSound(frequency, duration, type = 'sine') {
    try {
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      oscillator.frequency.value = frequency;
      oscillator.type = type;
      gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
      oscillator.start(audioCtx.currentTime);
      oscillator.stop(audioCtx.currentTime + duration);
    } catch (e) {}
  }

  // 主循環
  function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  // 重新開始
  function restartGame() {
    obstacles = [];
    particles = [];
    playerLane = 1;
    speed = baseSpeed;
    frameCount = 0;
    score = 0;
    gameOver = false;
    restartBtn.style.display = 'none';
    scoreDisplay.textContent = '得分: 0';
    initScenery();
  }

  // 啟動遊戲
  gameLoop();
</script>
</body>
</html>